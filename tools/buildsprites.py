#!/usr/bin/python3

import json
from PIL import Image
import numpy as np
from enum import Enum
import math
import sys
import argparse


#tables from https://github.com/AndiB/PETSCIItoASCII/blob/master/src/python/tables.py
petToAscTable = [
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x14,0x09,0x0d,0x11,0x93,0x0a,0x0e,0x0f,
0x10,0x0b,0x12,0x13,0x08,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x0c,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
0x60,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x7b,0x7c,0x7d,0x7e,0x7f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf
]

ascToPetTable = [
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x14,0x20,0x0d,0x11,0x93,0x0a,0x0e,0x0f,
0x10,0x0b,0x12,0x13,0x08,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0x5b,0x5c,0x5d,0x5e,0x5f,
0xc0,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0xdb,0xdc,0xdd,0xde,0xdf,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x0c,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
]


#CODE FROM SPRITE SHEET PARSER


class Frame:
	def __init__(self, x_offset, y_offset):
		self.x_offset = x_offset
		self.y_offset = y_offset

class Animation:
	def __init__(self, frame_array):
		self.frame_array = frame_array

class Color:
	def __init__(self, r, g, b):
		self.red = r
		self.green = g
		self.blue = b

	def hexvalue(self):
		bp = (self.blue) & 0x0F
		gp = ((self.green) << 4) & 0xF0
		rp = ((self.red) << 8) & 0xF00
		return bp+gp+rp

class readMode(Enum):
	NONE = 0
	FILE = 1
	NAME = 2
	SPRITESIZE = 3
	FRAMES = 4
	ANIMATIONS = 5
	PALETTE = 6




#
# name = ""
# filename = ""
#
# # parse arguments
# parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
#     description='Converts a Spritesheet and png file to Commander X16 sprite data.\n\n'
#     'Examples:\n\n'
#     'spritesheetparser.py -s sheet1.spritesheet sheet1.inc\n')
# parser.add_argument('output', help='the output file name')
# parser.add_argument('-f', default='c', choices=['c','basic','acme'], help='output format: c for C array, basic for BASIC, acme for ACME assembler, default: c')
# parser.add_argument('-s', help='File that contains the spritesheet description')
# args = parser.parse_args()
#

# default x16 palette
# default_palette = [
# 0x0000,0xfff,0x800,0xafe,0xc4c,0x0c5,0x00a,0xee7,0xd85,0x640,0xf77,0x333,0x777,0xaf6,0x08f,0xbbb,0x000,0x111,0x222,0x333,0x444,0x555,0x666,0x777,0x888,0x999,0xaaa,0xbbb,0xccc,0xddd,0xeee,0xfff,0x211,0x433,0x644,0x866,0xa88,0xc99,0xfbb,0x211,0x422,0x633,0x844,0xa55,0xc66,0xf77,0x200,0x411,0x611,0x822,0xa22,0xc33,0xf33,0x200,0x400,0x600,0x800,0xa00,0xc00,0xf00,0x221,0x443,0x664,0x886,0xaa8,0xcc9,0xfeb,0x211,0x432,0x653,0x874,0xa95,0xcb6,0xfd7,0x210,0x431,0x651,0x862,0xa82,0xca3,0xfc3,0x210,0x430,0x640,0x860,0xa80,0xc90,0xfb0,0x121,0x343,0x564,0x786,0x9a8,0xbc9,0xdfb,0x121,0x342,0x463,0x684,0x8a5,0x9c6,0xbf7,0x120,0x241,0x461,0x582,0x6a2,0x8c3,0x9f3,0x120,0x240,0x360,0x480,0x5a0,0x6c0,0x7f0,0x121,0x343,0x465,0x686,0x8a8,0x9ca,0xbfc,0x121,0x242,0x364,0x485,0x5a6,0x6c8,0x7f9,0x020,0x141,0x162,0x283,0x2a4,0x3c5,0x3f6,0x020,0x041,0x061,0x082,0x0a2,0x0c3,0x0f3,0x122,0x344,0x466,0x688,0x8aa,0x9cc,0xbff,0x122,0x244,0x366,0x488,0x5aa,0x6cc,0x7ff,0x022,0x144,0x166,0x288,0x2aa,0x3cc,0x3ff,0x022,0x044,0x066,0x088,0x0aa,0x0cc,0x0ff,0x112,0x334,0x456,0x668,0x88a,0x9ac,0xbcf,0x112,0x224,0x346,0x458,0x56a,0x68c,0x79f,0x002,0x114,0x126,0x238,0x24a,0x35c,0x36f,0x002,0x014,0x016,0x028,0x02a,0x03c,0x03f,0x112,0x334,0x546,0x768,0x98a,0xb9c,0xdbf,0x112,0x324,0x436,0x648,0x85a,0x96c,0xb7f,0x102,0x214,0x416,0x528,0x62a,0x83c,0x93f,0x102,0x204,0x306,0x408,0x50a,0x60c,0x70f,0x212,0x434,0x646,0x868,0xa8a,0xc9c,0xfbe,0x211,0x423,0x635,0x847,0xa59,0xc6b,0xf7d,0x201,0x413,0x615,0x826,0xa28,0xc3a,0xf3c,0x201,0x403,0x604,0x806,0xa08,0xc09,0xf0b
# ]
# default_palette.reverse()



def parseSpriteSheet(spritename, tilemode = 0):

	mode = readMode.NONE;

	spriteSize = (0,0)
	frames = []
	animations = []


	palette = {0: Color(0,0,0)}
	nextpaletteentry = 1
	filename = "images/" + spritename + ".spritesheet"
	with open(filename, "r") as fileIn:
		f1 = fileIn.readlines()
		for x in f1:
			if(x.startswith("!")):
				if(x == "!file\n"):
					mode = readMode.FILE
				if(x == "!name\n"):
					mode = readMode.NAME
				if(x == "!spritesize\n"):
					mode = readMode.SPRITESIZE
				if(x == "!frames\n"):
					mode = readMode.FRAMES
				if(x == "!animations\n"):
					mode = readMode.ANIMATIONS
				if(x == "!tile\n"):
					tilemode = 1
				if(x == "!palette\n"):
					mode = readMode.PALETTE
			elif(len(x)!=1):
				if(mode == readMode.FILE):
					x = x.strip("\n ")
					filename = x
				elif(mode == readMode.NAME):
					x = x.strip("\n ")
					name = x
				elif(mode == readMode.SPRITESIZE):
					x = x.strip("\n ")
					x=x.split(",")
					if(len(x)!=2):
						print("ERROR!  improper sprite size\n")
						break
					spriteSize = (int(x[0]),int(x[1]))

				elif(mode == readMode.FRAMES):
					if(tilemode == 1):
						x = x.strip("\n")
						x = x.split(",")
						x_tiles = int(x[0])
						y_tiles = int(x[1])
						x_pixel_size = spriteSize[0]
						y_pixel_size = spriteSize[1]
						for row in range(y_tiles):
							for col in range(x_tiles):
								x_coord = col * x_pixel_size
								y_coord = row * y_pixel_size
								frames.append(Frame(int(x_coord),int(y_coord)))
					else:
						x = x.strip("\n")
						x = x.split(":")
						key = int(x[0])
						x = x[1].split(",")
						frames.append(Frame(int(x[0]),int(x[1])))

				elif(mode == readMode.ANIMATIONS):
					x = x.strip("\n")
					x = x.split(":")
					key = int(x[0])
					framesStrings = x[1].split(",")
					frameList = []
					for frame in framesStrings:
						x = frame.split("~")
						frameKey = x[0]
						frameDuration = x[1]
						frameList.append((int(frameKey),int(frameDuration)))

					animations.append(Animation(frameList))

				elif(mode == readMode.PALETTE):
					x = x.strip("\n")
					x = x.split(",")
					red = int(x[0],16)
					green = int(x[1],16)
					blue = int(x[2],16)
					palette[nextpaletteentry] = Color(red,green,blue)
					nextpaletteentry += 1


		fileIn.close()

	# load image
	im = Image.open(filename)
	# palettelist = im.getpalette()
	# print(palettelist)
	# palette = {}
	# for i in range(16):
	# 	red = palettelist[i*3]
	# 	green = palettelist[i*3+1]
	# 	blue = palettelist[i*3+2]
	# 	palette[i] = Color(red, green, blue)
	#
	# print(palette[2].red)
	# print(palette[2].green)
	# print(palette[2].blue)
	p = np.array(im)


	# info table file output
	if(tilemode==0):
		# fileOut.write("%s_data:\n" % name)
		# fileOut.write("	!16 $0000 ;Vram offset will be set here\n") #Will be populated in game by vram offset
		write_word(0)
		# fileOut.write("	!16 $%04x ; Frame offset\n" % (spriteSize[0]*spriteSize[1]//2)) # frame offset
		write_word((spriteSize[0]*spriteSize[1]//2))
		# fileOut.write("	!8 $%02x ;number of frames\n" % len(frames)) #Number of frames
		write_byte(len(frames))
		# fileOut.write("	!8 $%02x ;number of animations\n" % len(animations)) #Number of frames
		write_byte(len(animations))
		#write animation data
	    # animations can have up to 4 frames
	    # data is layed out
	    # {FRAME INDEX 1} {DURATION} {FRAME INDEX 2} {DURATION} {FRAME INDEX 3} {DURATION} {FRAME INDEX 4} {DURATION}
		#fileOut.write("%s_animations:\n" % name)

		for animation in animations:
			# fileOut.write("    !byte ")
			for i in range(0,4):
				if(len(animation.frame_array) <= i):
					#fileOut.write("$%02x,$%02x" % (0,0))
					write_word(0)
				else:
					frame = animation.frame_array[i]
					# fileOut.write("$%02x,$%02x" % (frame[0],frame[1]))
					write_byte(frame[0])
					write_byte(frame[1])

			# fileOut.write("\n")

		write_string(spritename + ".spr")
		# fileOut.write("%s_filename_length:\n" %name)
		# fileOut.write("	!byte %s\n" %(len(name)+2))
		# fileOut.write("%s_filename:\n" %name)
		# fileOut.write("	!pet \"%s.o\"" % name)

		# fileOut.close()

	#data file output
	dataFilename = ""
	if(tilemode == 0):
		dataFilename = spritename.upper() + ".SPR"
	else:
		dataFilename = spritename.upper() + ".TSH"
	with open(dataFilename, "wb") as fileOut:
		data_out = []
		# fileOut.write("!to \"%s.O\", cbm\n*=0\n" % name.upper())

		#write data
		# fileOut.write("%s:\n" % name)
		for frame in frames:
			for y in range(frame.y_offset,spriteSize[1]+frame.y_offset):
				# fileOut.write("    !byte ")
				rowBest = []
				for x in range(frame.x_offset,frame.x_offset+spriteSize[0]):
					# get pixel color
					r, g, b, a = p[y][x]

					# use index 0 for transparent color
					if a == 0:
						best = 0
						#print("Transparent!")
					else:
						#print("Not transparent!")
						# find best palette match, start searching from top to allow index 16 for black color
						d = 1e9
						best = 0
						for key in palette.keys():
							if key == 0:
								continue
							entry = palette[key].hexvalue()
							rp = ((entry >> 8) & 0xf) << 4
							gp = ((entry >> 4) & 0xf) << 4
							bp = (entry & 0xf) << 4
							dr = r - rp
							dg = g - gp
							db = b - bp
							d0 = dr * dr + dg * dg + db * db

							if d0 < d: #32,112,240
								best = key
								d = d0
					#print("Appending: %s" % best)
					rowBest.append(best)

				# write palette index
				i = 1
				while (i <len(rowBest)):
					best = (rowBest[i] << 4) + rowBest[i-1]
					textformat = "{0:x}{1:x}"
					formatted = textformat.format(best & 0x0F,best >> 4)
					# fileOut.write("$%01x%01x" % (best & 0x0F,best >> 4))

					value = int(formatted,16)

					data_out.append(value)
					# if (i < len(rowBest)-1):
					# 	fileOut.write(",")
					i += 2
				# fileOut.write("\n")
		fileOut.write(bytes(b'\x00\x00'))
		fileOut.write(bytes(data_out))
		fileOut.close()



parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
	description='Converts a sprite config file into SPRITE.IND and SPR files.\n\n'
	'Examples:\n\n'
	'buildsprites.py sprite.cfg\n')
parser.add_argument('-input', default='sprite.cfg', help='the sprite config file')
args = parser.parse_args()

spritenames = []
tilenames = []
output_bytes = []
temp_output_bytes = []

def clear_output():
	global output_bytes
	output_bytes = []

def write_byte(inByte):
	global output_bytes
	output_bytes.append(inByte & 0xFF)

def write_word(word):
	lowByte = word & 0xFF
	highByte = word >> 8
	write_byte(lowByte)
	write_byte(highByte)

def write_string(str):
	write_byte(len(str))
	str = str.lower()
	for char in str:
		write_byte(ascToPetTable[ord(char)])

def skip_to_address(address):
	global output_bytes
	while(len(output_bytes) != address):
		write_byte(0)

with open(args.input, "r") as read_file:
	f1 = read_file.readlines()
	i = 0
	readingTiles = 0
	ilen = len(f1)
	while(i < ilen):
		string = f1[i].strip(' \n')
		if(len(string)>0):
			if(not readingTiles):
				spritenames.append(string)
			else:
				tilenames.append(string)
		else:
			readingTiles = 1
		i+=1






clear_output()
write_byte(len(spritenames))

#for each sprite, leave 16 bit entries blank for now
for i in range(len(spritenames)):
	write_word(0)


#write each index entry
for i in range(len(spritenames)):
	# write address offset
	current_address = len(output_bytes) - 1 #the first byte is not counted
	top_byte = current_address >> 8
	bottom_byte = current_address & 0xFF
	output_bytes[1+2*i] = bottom_byte
	output_bytes[2+2*i] = top_byte
	#write address entry
	name = spritenames[i]
	parseSpriteSheet(name)



#write index file
with open('SPRITE.IND',"wb") as ind_file:
	#WRITE INDEX FILE
	ind_file.write(bytes(b'\x00\x00'))
	ind_file.write(bytes(output_bytes))


#write each index entry
for i in range(len(tilenames)):
	name = tilenames[i]
	parseSpriteSheet(name,1)



#print(palettes)
